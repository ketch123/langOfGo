# プログラミング言語 GO tips

## 第1章
* **ゴルーチン(gorutine)**
  * 関数の平行した実行
* **チャネル(channel)**
  * ゴルーチンが特定の型を持つ値を他のゴルーチンへ渡すことを可能にする通信機構
* **ブランク識別子(\_)**
  * 構文として変数名が必要だが、プログラムがその変数を必要としない場合に使用する  
  * i,e : `_, arg := range os.Args[1:]`  
    この場合、`os.Args[]`はインデックスとインデックスの位置にある要素の値を返すが、インデックスを使用しないということ
* **sync.Mutex**
  * mutexを使って排他制御を行うことができる
* **Goのポインタ**
  * Cと他の言語の中間的立場
  * ポインタ型の変数の宣言やポインタを使ったアドレスの表示、値の表示などは可能
  * ポインタの演算は不可能
***
## 第2章
* **スコープ**
  * 関数外で宣言されたものはどこからでも参照できる
  * 基本的に関数内で宣言されたものは関数内でしか参照できない
    * 例外として、関数内で**先頭が大文字**で宣言されたものは**それが属するパッケージのすべてのファイル**から参照できる
* **命名規則**
  * 基本的にはスコープが狭いものほど短く、広いものほど長く命名する
  * キャメルケースを使用する
* **関数**
  * 返り値の型は明示的に宣言することもできる
    * i,e, : `func funcName(i int) int`
* **変数**
  * var宣言の基本形は`var name type = expression`
    * `type`が省略された場合には型はexpressionの型になり、`= expression`が省略された場合には、`type`のゼロ値で初期化される
    * よってGoには**未初期化の変数というものは存在しない**
  * パッケージレベルの変数はmainが始まる前に初期化され、ローカル変数は関数実行中の宣言部分で初期化される
* **省略変数宣言**
  * `name := expression`をとり、`expression`の型がそのまま`name`の型となる
  * ローカル変数の大多数はこの形式で宣言
  * 対してvar宣言は明示的な方宣言が必要な場合や、変数の初期値が重要でない場合に使われる
  * 複数の変数を同時に省略宣言することもできるが、可読性が向上する場合のみ使うべき(forの初期化部分など)
  * `:=`は**宣言であり、代入(`=`)ではない**
    * ただし、同一ブロック内ですでに宣言されているブロックに対し省略変数宣言を行った場合、その変数に対しては代入のように働く
    * 少なくとも１つの変数を宣言していなければならない
* **ポインタ**
  * ゼロ値はnil
  * すべての変数はポインタをもつ
    * よって`*p != nil`は`p`が変数を指していれば必ず真になる
  * ポインタの比較は可能
* **new**
  * `new(T)`によってT型の無名変数を作ることができる
    * T型のゼロ値で初期化され、変数に対する\*T型のアドレスを返す
  * 基本的に呼び出しごとに一意なアドレスを返す
    * 例外として、`struct{}`や`[0]int`など大きさが0の型の2つの変数は、同じアドレスを返す可能性がある(実装依存)
* **変数の生存期間**
  * パッケージレベルの変数の生存期間はプログラムの実行全体
  * ローカル変数の生存期間は**到達不可能**になるまで
    * 例えば  
    ```
    var global *int
    func f() {
        var x int
        x = 1
        global = &x
    }
    ```
    のようなコードの場合、`x`は関数終了後も`global`から参照されるので**到達可能**となる  
    このようなとき、`x`は関数`f`から**エスケープ**しているという
    * 一方、
    ```
    func g() {
        y := new(int)
        *y = 1
    }
    ```
    のようなコードの場合、`y`は関数終了時点でどこからも参照されなくなるので**到達不可能**となる  
    このようなとき、`y`は関数`g`から**エスケープ**していない
  * エスケープしている変数は、コンパイラによって**ヒープ**に割り当てられる
  * 一方エスケープしていない変数の場合**スタック**に割り当てられる
  * Goのガベージコレクタはこのようなことからメモリ回収のタイミングを知る
  * 効率的なコードを書くためには生存期間について考えることも重要
    * 長い間生存するオブジェクトの中に短命なオブジェクトへのポインタを維持しておくと、短命なオブジェクトのメモリ回収のタイミングを阻害する
  * **パッケージ**
    * 個々のパッケージはその宣言に対して別々の名前空間としての機能を果たす
    * 各パッケージには**ドックコメント**というパッケージ全体としてのドキュメントがある
      * ドックコメントは基本的にパッケージに関連するファイル群の中の1つにのみある
      * 大抵はドックコメントだけを目的とするファイル`doc.go`の中にある
    * 初期化はパッケージの依存関係の下位から上位へ順に行われる
* **スコープ**
  * スコープと生存期間を混同させないように注意する
    * スコープはプログラムテキストの範囲、すなわちコンパイル時の特性のこと
    * 生存期間はその変数がプログラムの他の部分から参照できる実行時の時間の範囲、すなわち実行時の特性のこと
* **ブロック**
  * 明示的に`{}`で囲まれた宣言や`{}`で囲まれない宣言の他のグループ化などを総称して**レキシカルブロック**といい、ソースコード全体を**ユニバースブロック**という
  * コンパイラが変数の名前への参照を見つけたとき、最も内側にあるレキシカルブロックからユニバースブロックに達するまで宣言を探し、見つけられなかったとき`undeclared name`のエラーを返す
